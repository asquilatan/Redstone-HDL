"""
Main Compiler: Orchestrates the compilation pipeline
"""
from dataclasses import dataclass, field
from typing import Optional, List, Tuple, Dict
from pathlib import Path
import sys

# Add src to path
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from redscript.compiler.voxel_grid import VoxelGrid, Block
from redscript.compiler.logical_graph import LogicalGraph, Component, Connection, ComponentType
from redscript.compiler.parser.parser import RedScriptParser
from redscript.compiler.sequencer.sequencer import KinematicSequencer
from redscript.compiler.safety import KinematicSafety
from redscript.compiler.timing.engine import TimingEngine
from redscript.compiler.errors import ErrorReporter, CompileError, ErrorType

@dataclass
class CompileOptions:
    """Compilation options"""
    optimize: bool = True
    export_format: str = "litematic"
    verbose: bool = False
    debug: bool = False

@dataclass
class CompileResult:
    """Result of compilation"""
    success: bool
    schematic: Optional['Schematic'] = None
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)

class Schematic:
    """Represents the compiled 3D structure"""
    
    def __init__(self, voxel_grid: VoxelGrid, logical_graph: LogicalGraph):
        self.voxel_grid = voxel_grid
        self.logical_graph = logical_graph
        self.author = "RedScript Compiler"
        self.description = "Generated by RedScript"
    
    def save(self, path: str) -> None:
        """Writes the schematic to disk"""
        from redscript.utils.serializer import LitematicaSerializer
        LitematicaSerializer.serialize(self.voxel_grid, path)
    
    def to_voxel_grid(self) -> VoxelGrid:
        """Returns the internal voxel grid"""
        return self.voxel_grid
    
    def get_block_count(self) -> int:
        """Returns the total number of placed blocks"""
        return len(self.voxel_grid.blocks)


class Compiler:
    """Main entry point for the RedScript compiler"""
    
    # Block placement offsets for component types
    COMPONENT_BLOCKS = {
        ComponentType.PISTON: [
            ((0, 0, 0), "minecraft:piston", {"facing": "up"}),
        ],
        ComponentType.STICKY_PISTON: [
            ((0, 0, 0), "minecraft:sticky_piston", {"facing": "up"}),
        ],
        ComponentType.REPEATER: [
            ((0, 0, 0), "minecraft:repeater", {"facing": "north", "delay": "1"}),
        ],
        ComponentType.LEVER: [
            ((0, 0, 0), "minecraft:lever", {"face": "floor", "facing": "north"}),
        ],
        ComponentType.LAMP: [
            ((0, 0, 0), "minecraft:redstone_lamp", {}),
        ],
        ComponentType.OBSERVER: [
            ((0, 0, 0), "minecraft:observer", {"facing": "up"}),
        ],
        ComponentType.DROPPER: [
            ((0, 0, 0), "minecraft:dropper", {"facing": "down"}),
        ],
        ComponentType.COMPARATOR: [
            ((0, 0, 0), "minecraft:comparator", {"facing": "north", "mode": "compare"}),
        ],
        ComponentType.HOPPER: [
            ((0, 0, 0), "minecraft:hopper", {"facing": "down", "enabled": "true"}),
        ],
        ComponentType.TARGET: [
            ((0, 0, 0), "minecraft:target", {}),
        ],
        ComponentType.SLIME_BLOCK: [
            ((0, 0, 0), "minecraft:slime_block", {}),
        ],
        ComponentType.HONEY_BLOCK: [
            ((0, 0, 0), "minecraft:honey_block", {}),
        ],
        ComponentType.REDSTONE_TORCH: [
            ((0, 0, 0), "minecraft:redstone_torch", {}),
        ],
        ComponentType.PRESSURE_PLATE: [
            ((0, 0, 0), "minecraft:stone_pressure_plate", {}),
        ],
        ComponentType.BUTTON: [
            ((0, 0, 0), "minecraft:stone_button", {"face": "floor", "facing": "north"}),
        ],
        ComponentType.STONE: [
            ((0, 0, 0), "minecraft:stone", {}),
        ],
        ComponentType.REDSTONE_WIRE: [
            ((0, 0, 0), "minecraft:redstone_wire", {"power": "0"}),
        ],
        ComponentType.GLAZED_TERRACOTTA: [
            ((0, 0, 0), "minecraft:magenta_glazed_terracotta", {"facing": "north"}),
        ],
        ComponentType.GLASS: [
            ((0, 0, 0), "minecraft:glass", {}),
        ],
    }
    
    def __init__(self):
        self.options = CompileOptions()
        self.parser = RedScriptParser()
        self.sequencer = KinematicSequencer()
        self.timing_engine = TimingEngine()
        self.error_reporter = ErrorReporter()
    
    def compile(self, source_code: str, options: Optional[CompileOptions] = None) -> CompileResult:
        """
        Compiles RedScript source code into a Minecraft Schematic.
        
        Args:
            source_code: The raw string content of the .rs file.
            options: Compilation settings.
            
        Returns:
            CompileResult with schematic or errors.
        """
        if options:
            self.options = options
        
        result = CompileResult(success=False)
        
        try:
            # Phase 1: Parse to AST
            if self.options.verbose:
                print("Phase 1: Parsing...")
            ast = self.parser.parse(source_code)
            
            # Phase 2: Transform to LogicalGraph
            if self.options.verbose:
                print("Phase 2: Sequencing...")
            self.sequencer = KinematicSequencer()  # Reset for new compilation
            logical_graph = self.sequencer.transform(ast)
            
            # Phase 3: Validate Safety
            if self.options.verbose:
                print("Phase 3: Safety validation...")
            is_safe, safety_errors = KinematicSafety.validate(logical_graph)
            if not is_safe:
                for err in safety_errors:
                    result.errors.append(f"Safety violation: {err}")
                return result
            
            # Phase 4: Place components in VoxelGrid
            if self.options.verbose:
                print("Phase 4: Placing components...")
            voxel_grid = self._place_components(logical_graph)
            
            # Phase 5: Route signals between components
            if self.options.verbose:
                print("Phase 5: Routing signals...")
            self._route_signals(voxel_grid, logical_graph)
            
            # Phase 5.5: Validate no floating blocks (after routing)
            floating_errors = self._validate_floating_blocks(voxel_grid)
            if floating_errors:
                for err in floating_errors:
                    result.errors.append(f"Floating block: {err}")
                return result
            
            # Phase 6: Apply timing (insert repeaters)
            if self.options.verbose:
                print("Phase 6: Timing synchronization...")
            delays = self.timing_engine.calculate_delays(logical_graph)
            # Note: Repeaters are inserted during routing based on delays
            
            # Success!
            result.success = True
            result.schematic = Schematic(voxel_grid, logical_graph)
            
            if self.options.verbose:
                print(f"Compilation successful: {result.schematic.get_block_count()} blocks placed")
            
        except SyntaxError as e:
            result.errors.append(f"Syntax error: {e}")
        except ValueError as e:
            result.errors.append(f"Value error: {e}")
        except Exception as e:
            result.errors.append(f"Compilation error: {e}")
        
        return result
    
    def _place_components(self, graph: LogicalGraph) -> VoxelGrid:
        """Place components in the voxel grid based on their positions"""
        grid = VoxelGrid(width=64, height=64, depth=64)
        
        # Auto-layout: arrange components in a grid if positions not specified
        component_list = list(graph.components.values())
        for i, component in enumerate(component_list):
            # Get position from properties or auto-layout
            pos = self._get_component_position(component, i)
            
            # Get blocks for this component type
            blocks = self.COMPONENT_BLOCKS.get(component.type, [])
            
            for (offset, material, props) in blocks:
                bx = pos[0] + offset[0]
                by = pos[1] + offset[1]
                bz = pos[2] + offset[2]
                
                # Merge component properties with block properties
                merged_props = {**props}
                
                # Copy relevant properties from component definition
                # These override the defaults in COMPONENT_BLOCKS
                relevant_props = [
                    'facing', 'delay', 'mode', 'face', 'type', 'enabled', 
                    'powered', 'locked', 'open', 'power',
                    'north', 'south', 'east', 'west',  # Redstone wire connections
                    'attachment', 'extended', 'short',  # Pistons
                ]
                
                for prop in relevant_props:
                    if prop in component.properties:
                        # Ensure value is string for Block properties
                        val = component.properties[prop]
                        # Strip quotes if present (parser should have done this but just in case)
                        if isinstance(val, str) and val.startswith('"') and val.endswith('"'):
                            val = val[1:-1]
                        merged_props[prop] = str(val)
                
                block = Block(material=material, properties=merged_props)
                grid.set_block(bx, by, bz, block)
        
        return grid
    
    def _validate_floating_blocks(self, grid: VoxelGrid) -> List[str]:
        """Validate that blocks requiring support have a solid block underneath."""
        errors = []
        
        # Materials that require support underneath
        needs_support = [
            'minecraft:redstone_wire',
            'minecraft:stone_button',
            'minecraft:lever',
            'minecraft:stone_pressure_plate',
        ]
        
        # Non-solid materials that cannot provide support
        non_solid = [
            'minecraft:air',
            'minecraft:redstone_wire',
            'minecraft:stone_button',
            'minecraft:lever',
            'minecraft:stone_pressure_plate',
            'minecraft:repeater',
            'minecraft:comparator',
            'minecraft:redstone_torch',
            'minecraft:piston',
            'minecraft:sticky_piston',
        ]
        
        for (x, y, z), block in grid.blocks.items():
            if block.material in needs_support:
                # Check if there's a solid block underneath
                below = grid.get_block(x, y - 1, z)
                if below is None or below.material in non_solid:
                    errors.append(f"{block.material} at ({x}, {y}, {z}) requires a solid support block underneath")
        
        return errors
    
    def _get_component_position(self, component: Component, index: int) -> Tuple[int, int, int]:
        """Get the world position for a component"""
        # Check if position is specified in properties
        # Check if position is specified in properties
        if 'position' in component.properties:
            pos_str = component.properties['position']
            # Parse position string like "(0, 0, 0)"
            if isinstance(pos_str, str):
                pos_str = pos_str.strip("()")
                parts = [int(x.strip()) for x in pos_str.split(",")]
                return tuple(parts)
            elif isinstance(pos_str, tuple):
                return pos_str
        elif 'pos' in component.properties:
            pos_str = component.properties['pos']
            # Parse position string like "(0, 0, 0)"
            if isinstance(pos_str, str):
                pos_str = pos_str.strip("()")
                parts = [int(x.strip()) for x in pos_str.split(",")]
                return tuple(parts)
            elif isinstance(pos_str, tuple):
                return pos_str
        
        # Auto-layout: place components in a row with spacing
        spacing = 4
        x = (index % 4) * spacing + 10
        z = (index // 4) * spacing + 10
        y = 5  # Slightly above ground level
        
        return (x, y, z)
    
    def _route_signals(self, grid: VoxelGrid, graph: LogicalGraph) -> None:
        """Route redstone wiring between connected components"""
        from redscript.solver.interface import SolverInterface
        
        solver = SolverInterface()
        solver.load_grid(grid)
        
        for conn in graph.connections.values():
            # Find source and target component positions
            source_comp = None
            target_comp = None
            
            for comp in graph.components.values():
                for port in comp.outputs:
                    if port.id == conn.source_port_id:
                        source_comp = comp
                        break
                for port in comp.inputs:
                    if port.id == conn.target_port_id:
                        target_comp = comp
                        break
            
            if source_comp and target_comp:
                # Get positions
                src_pos = self._get_component_position(source_comp, 
                    list(graph.components.keys()).index(source_comp.id))
                tgt_pos = self._get_component_position(target_comp,
                    list(graph.components.keys()).index(target_comp.id))
                
                # Route redstone between them
                success, path = solver.route_signal(src_pos, tgt_pos, 
                    signal_strength=conn.signal_strength, delay=conn.min_delay)
                
                if success:
                    # Non-solid materials that cannot support redstone
                    non_solid = [
                        'minecraft:air',
                        'minecraft:redstone_wire',
                        'minecraft:stone_button',
                        'minecraft:lever',
                        'minecraft:stone_pressure_plate',
                        'minecraft:repeater',
                        'minecraft:comparator',
                        'minecraft:redstone_torch',
                    ]
                    
                    # Place redstone wire along path with support blocks
                    for i, (x, y, z) in enumerate(path[1:-1], 1):  # Skip endpoints
                        # Check if position already has a non-air block
                        existing = grid.get_block(x, y, z)
                        if existing is not None and existing.material != 'minecraft:air':
                            # Skip if there's already something here
                            continue
                        
                        # First ensure support exists below (place stone if needed)
                        below = grid.get_block(x, y - 1, z)
                        if below is None or below.material in non_solid:
                            support = Block(material="minecraft:stone", properties={})
                            grid.set_block(x, y - 1, z, support)
                        
                        # Now place the wire
                        wire = Block(material="minecraft:redstone_wire", 
                                   properties={"power": "15"})
                        grid.set_block(x, y, z, wire)


def compile_file(input_path: str, output_path: Optional[str] = None, optimize: bool = True) -> CompileResult:
    """CLI helper to compile a file"""
    # Read input
    with open(input_path, 'r') as f:
        source = f.read()
    
    # Compile
    compiler = Compiler()
    result = compiler.compile(source, CompileOptions(optimize=optimize, verbose=True))
    
    # Write output if successful
    if result.success and result.schematic:
        if output_path:
            result.schematic.save(output_path)
        else:
            output_path = input_path.replace('.rs', '.litematic')
            result.schematic.save(output_path)
    
    return result
